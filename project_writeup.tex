\documentclass[11pt]{article}
\usepackage{cite}
\usepackage{amsmath}
% \usepackage{fullpage}
\usepackage[top=1in, bottom=1in, left=0.8in, right=1in]{geometry}
\usepackage{multicol}
\usepackage{amsfonts}
\usepackage{wrapfig}
\usepackage{mathtools}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage{titlesec}
\usepackage[section]{placeins}
\usepackage[font={small,it}]{caption}
\usepackage{amsthm}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{float}
\usepackage{hyperref}
\newfloat{algorithm}{t}{lop}


\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\newcommand{\overbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\W}{\mathcal{W}}
\renewcommand{\L}{\mathcal{L}}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\pe}{^{\perp}}
\newcommand{\ep}{\epsilon}
\renewcommand{\lim}{\text{lim}}
\newcommand{\inj}{\hookrightarrow}
\newcommand{\aut}{\operatorname{Aut}}
\newcommand{\Aut}{\operatorname{Aut}}
\renewcommand{\split}{\operatorname{Split}}
\newcommand{\characteristic}{\operatorname{Char}}
\newcommand{\LCM}{\operatorname{LCM}}
\newcommand{\ov}{\overline}
\newcommand{\gal}{\operatorname{Gal}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}

\setlength{\columnsep}{1pc}

\title{Leela: Cheating-Resistant Distributed Game Engines}
\author{Leo Martel, Susan Tu, Andy Moreland \\ \tt{\{lmartel, susanctu, andymo\}@stanford.edu}}
\date{\today}
\begin{document}

\maketitle

\begin{multicols}{2}

\section{Abstract}
In this paper we present Leela, a distributed multiplayer game engine that is Byzantine fault-tolerant. Leela allows games to be written with little regard for issues such as move replication, rejection of cheating moves, allowing new players to join the game, allowing players to leave the game, and removing cheating or network-partitioned players from the game. Leela is based on \emph{Practical Byzantine Fault Tolerance} \cite{castro} and we seek to demonstrate through benchmarks that Leela is a practical underpinning for multiplayer games.
\section{Design Overview}
\subsection{Protocol for Byzantine Threats}

Our protocol is heavily based on \emph{Practical Byzantine Fault Tolerance} (PBFT). In our setup, one player is simultaneously a client and the primary (also referred to as the server). All other players are simultaneously clients and replicas. We assume players can obtain each others' IP addresses, thrift ports, and public keys from some trusted 3rd party. (In the description below we assume $3f+1$ players, but our implementation correctly handles any number $n$ of players so that we can tolerate up to $\lfloor \frac{n-1}{3}\rfloor$ cheaters.)
\subsubsection{Submittng and Approving a Move}

Suppose we have some client A who wants to play a move. Client A sends this signed move to server. (This signed move the same as the client’s request in \cite{castro}): $<MOVE, move_info, timestamp, A_ID, signature>$. This move is run through PBFT. If the move looks valid, clients should eventually multicast a $COMMIT$ message indicating this. If not it should multicast an $<ACCUSE, viewstamp, D(move_info), i, A_ID signature>$ message, where $D$ indicates a digest and $viewstamp$ refers to a pair of view number and sequence number. (Note that we can skip the last reply to the client in PBFT since our client is the same as one of the replicas, and PBFT guarantees that once a move commits at an honest replica, it will eventually commit on at least $f+1$ honest replicas.) A replica that obtains $2f+1$ $COMMIT$ messages should commit the move to its log. A replica that does not send an $COMMIT$ message (because it does not think the move is valid) should send a $<MOVE, kick out A, timestamp, clientID, signature>$ as a request to the server and an $ACCUSE$ message in lieu of the $COMMIT$ message (so that other replicas know that it isn’t just not responding). To prevent many replicas from submitting a request to boot A at the same time, a replica should wait a randomized timeout before submitting this request. (We consider it not particularly important to boot cheating clients the instant they cheat, so the lag that results from this timeout is acceptable.) 

Clients should number their moves 1, 2, 3, etc. No honest replica should apply a $M$th move from client A that before it has applied A’s $M-1$ move. 

\subsubsection{Player Join}

New player P sends public key to all players and then sends a $<MOVE, join, ...>$ to the server, which gets run through PBFT. Non-faulty clients should all approve this unless the game is full.

\subsubsection{Player Leave}

If the player P intends to leave, P should send a $<MOVE, leave,...>$ request to the server, which gets run through PBFT. Non-faulty clients should all approve this.

If the server S claims has not heard from P in a while, it may be that (1) P has disconnected and should not longer be considered to be a part of the game or (2) the server is malicious. The server will run the request $<MOVE, kick out P, timestamp serverID, signature>$ through PBFT. In case (1), non-faulty clients will also not have heard from P, so they will vote for P’s removal. (Note that while is possible that network issues have partitioned P from the server but still allow it to contact other clients, thereby preventing the server from kicking out P, we don’t expect this to be the common case). In case (2), clients should vote against removal and remember that they refused a removal request from this server. Clients who voted against should initiate a view change. After the view change, some client that voted against removal of P (do this after a randomized timeout so we don’t get a bunch of these all at once) should issue a $<MOVE, kick out S, ...>$ request. All honest clients that voted against removal of P are expected to vote for this request.

For the purposes of detecting if a player has abruptly disconnected, the clients/server should keep track of who they got a PREPARE (or COMMIT, or ACCUSE) message from even if they no longer need that PREPARE message to consider themselves PREPARED. 

\subsubsection{Malicious Server}

Due to moves needing to be signed by the players proposing them, no malicious server can ‘make up’ moves; it can only fail to send PRE-PREPARES for them or be very slow to send PRE-PREPARES for them. Clients can time how long it takes for moves to be considered committed-local and initiate view changes if the avg time (for example) is considered to be too long. They can also periodically request that they receive a reply (as specified in the original PBFT paper) back from all clients for some requests so they can time how long it takes for the move to be committed everywhere (i.e., they might take the average time of the 2f+1 fastest).  

\subsection{Optimizations}

\section{Implementation}

\subsection{Layers of Abstraction}

(1) Log replication
(2) Game engine

\section{Benchmarking}

Graphs!



\section{Conclusion}

\begin{thebibliography}{9}

\bibitem{castro} M. Castro and B. Liskov. Practical Byzantine Fault Tolerance. \emph{Proceedings of the Thirf Symposium on Operating System Design and Implementation}, 1999.

\end{thebibliography}



\end{multicols}


\end{document}

